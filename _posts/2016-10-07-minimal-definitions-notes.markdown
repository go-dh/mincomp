---
layout: post
title:  "Minimal Definitions - Notes"
date:   2016-10-07 09:00:00
category: thoughts
author: Joel Hughes
---

The following is a loose set of notes and thoughts triggered by
Jentery Sayers's piece of the same title, defining the concepts of
_Minimal Computing_ <sub>[_[1](#ref1)_]</sub>. This is far from
scholarly, I'm not an academic but I do find this discussion very
interesting.

<sub>_Originally posted 2016-10-06: [rudenoise.uk](http://rudenoise.uk/md-mc-notes.html)_</sub>

> What do we need? - _Alex Gil_

My reflections are coloured by a career spent building software,
predominantly for the web.

> The emerging definitions of minimal computing and its frameworks
> fascinate me, in part because they engage various histories of
> technology at the intersection of aesthetics and politics.
> - _Jentery Sayers_

## Minimal Design

I'm reminded of the _Law of Requisite Variety_ aka _Ashby's Law_
<sub>[_[4](#ref4)_]</sub>. To achieve minimalism, either the variety
should be reduced or the complexity of the control-system increased
(hiding the complexity from the end user).

In its technical implementation, Jekyll only moves the complexity
around, the overall reduction in the system's complexity is
negligible. Does the ability to modify the software affect its
minimalism?

Agree that reducing the design and UI functions is beneficial and in
keeping with the principles of _Minimal Computing_, so far.

The notion of a "minimal" system is very subjective. In most cases,
assuming that the complexity is essential, what remains can be hidden
from the user (at the expense of understanding/learning and
flexibility) or revealed at the surface (at the expense of first-time
comprehension). See Bret Victor <sub>[_[5](#ref5)_]</sub>.

> working through these entanglements of writing with programming.

Kunth's _Literate Programming_ <sub>[_[6](#ref6)_]</sub> while
appealing has never taken a strong hold in the code bases that I work
on. Vikram Chandra would seem to agree on some degree of separation
in the properties of each medium, in his book: _Geek
Sublime_ <sub>[_[7](#ref7)_]</sub>.

An example that I prefer is the OpenBSD Operating System
<sub>[_[8](#ref8)_]</sub> with well tended and groomed source-code
coupled with an extensive and well thought out manual. The
implementation separate from the operation of the program yet both
following the same core principles and UNIX Philosophy. One medium
for the machine, another for the human.

## Minimal Use

Thinking on the division between the creation of tools and the
creation of content (as I'm working on the tools side of the
balance): the protocols and delivery methods of web-content are far
from minimal. Managing the raw material in _git_, publishing over
_FTP_, serving HTML over _HTTP_ and then continuing the conversation
over mail (_SMTP_) and proprietary systems like _Twitter_ and _Face
Book_.

This _could_ be consolidated into the use of _Git_ alone (or
another peer-to-peer versioning/branching system). In large
development teams a form of "conversation" is carried out over
branches, pull-requests and merges <sub>[_[9](#ref9)_]</sub>.
Not only is the creation of the content collaborative but a permanent
record is kept of the development of the ideas within.

Another _Git_ protocol advantage is its _peer-to-peer_ nature. It can
use a centralised server, but not essential. Always-on servers
consume massive amounts of energy, idling for the majority of the
time, coordinated pulling of _git_ repositories could be a foundation
for a far more energy efficient transfer, retrieval and storage of
textual records (or any digitised media).

While _HTML_ is a well adopted format browsers are hugely resource
hungry. Most modern sites are close to unusable in text-based tools
like _Linx_<sub>[_[10](#ref10)_]</sub>. Distributing content in simple
formats like _markdown_ over protocols similar to _git_ would almost
certainly reduce expended computing power.

## Minimal Consumption

Computing power, it seems to me, is largely consumed by graphics. For
example, the capabilities offered by the latest smart-phones
plateaued a few years back. The main driver for the upgrade-cycle is
the higher-resolution cameras, that store larger image-files that, in
turn, require a more pixel-dense screen to display them in all their
detail.

As image quality increases so do the demands on the network but also
the production of content to utilise it. The demand is generated by
the capabilities of the devices. The complexity of the
machines seems to be reducing the processor-cycles used for creative
activities and increasing those expended on consumption.

As a professional programmer, my requirements are minimal.
I'm writing this on a machine from 2007 which is blazingly fast for
most tasks.

## Minimal Barriers

Simple isn't the same as easy. Computer processors are very "simple",
they are capable of doing simple things repetitiously and very
quickly. For instance nearly all arithmetic in a processor can be
performed just by adding. This is _simple_ but not _easy_.

A problem I see in the projects that I work on is the drive to make
the barriers low for the users. In so doing constraints are placed on
functionality, there are fewer paths to follow so fewer mistakes can
be made. The trade-off is made when the user wishes to perform a
creative (rather than prescribed task) the system is inflexible.

You can reduce system complexity to a degree, after which
it can only be reordered.

## Minimal Internet

There are alternative technologies that could be adopted that support
these requirements, such as _Unikernel Operating Systems_.
By reducing the components of a server to only those needed for a
specific task, the code can be tiny, the energy consumption minimal
and they can even be turned off between page requests
<sub>[_[11](#ref11)_]</sub>.

## Minimal Technical Language

This area is one of the toughest social issues in professional
software-development. Debates over tools and methods are unending and
ever present. Especially as terminology is continually being coined
and re-purposed.

Movements like "_micro service architecture_" aim to reduce the need
for common implementation methods as long as components of large
systems describe to one-another how they can interoperate
<sub>[_[12](#ref12)_]</sub>.

More to follow...

## Links

1. <a id="ref1"></a> [Minimal Definitions, Minimal Computing - Jentery Sayers](http://go-dh.github.io/mincomp/thoughts/2016/10/02/minimal-definitions/)
2. <a id="ref2"></a> [The User, the Learner and the Machines We Make](http://go-dh.github.io/mincomp/thoughts/2015/05/21/user-vs-learner/)
3. <a id="ref3"></a> [The Beauty of Code](http://www.theparisreview.org/blog/2014/09/05/the-beauty-of-code/)
4. <a id="ref4"></a> [The Law of Requisite Variety](https://en.wikipedia.org/wiki/Variety_(cybernetics)#The_Law_of_Requisite_Variety)
5. <a id="ref5"></a> [Up and Down the Ladder of Abstraction](http://worrydream.com/LadderOfAbstraction/)
6. <a id="ref6"></a> [Literate Programming](https://en.wikipedia.org/wiki/Literate_programming)
7. <a id="ref7"></a> [Geek Sublime](https://www.graywolfpress.org/books/geek-sublime)
8. <a id="ref8"></a> [OpenBSD](https://www.openbsd.org/)
9. <a id="ref9"></a> [Git pull requests](https://help.github.com/articles/about-pull-requests/)
10. <a id="ref10"></a> [Lynx Browser](https://en.wikipedia.org/wiki/Lynx_(web_browser))
11. <a id="ref11"></a> [Unikernels: Rise of the Virtual Library Operating System](http://queue.acm.org/detail.cfm?id=2566628)
11. <a id="ref12"></a> [Microservices](http://martinfowler.com/articles/microservices.html)
